#!/usr/bin/env python3

"""
Simple utility to export as much info as possible about a given VPC so that it
can be visualized

Usage:
    wsh-vpc-viz [options]
    wsh-vpc-viz ( -h | --help )

Options:
    -v <vpc-id>, --vpc-id=<vpc-id>
                        Dump resources in the matching only VPC. Defaults to
                        creating one output per VPC discovered
    -o <output-dir>, --output=<output-dir>
                        Directory in which to output any resource created.
                        Defaults to the current directory [default: .]
    -f <output-format>, --format=<output-format>
                        Supported formats are; dot [default: dot]
    -d <dir>, --dir=<dir>
                        Graphviz graph direction. Only used for gviz output
                        Can be one of; BT, TB, RL, LR [default: TB]
    -x, --extra         Attempt GraphViz package detection and if found create
                        additional PNG and SVG outputs
    --no-ec2            Hide EC2 resources
    --no-routing        Hide VPC Routing resources (RouteTable)
    --no-cx             Hide private connection resources (DX, VPN, Peering)
    --debug             Show more verbose logging

Graphviz diagrams can be converted to images if you also have the 'dot'
packages installed. If the 'dot' command is available from the $PATH then
automatic conversion will be attempted

  PNG:  dot -Tpng aws-vpc-1234567.dot -o aws-vpc-1234567.png
  SVG:  dot -Tsvg aws-vpc-1234567.dot -o aws-vpc-1234567.svg

"""

import os
import sys
import distutils.spawn as sp
from wshutils.logger import WSHLog
from wshutils import clean_up
import docopt
from jinja2 import Environment, FileSystemLoader
import boto3
from colorama import init as colorama_init

###############################################################################
# CONFIG - Begin
###############################################################################

LUT_ROUTETABLE_ORIGIN = {
    'CreateRouteTable': 'Auto',
    'CreateRoute': 'Manual',
    'EnableVgwRoutePropagation': 'Dynamic'
}

###############################################################################
# CONFIG - End (Do Not Edit Below)
###############################################################################

_log = WSHLog(__file__)
colorama_init()

###############################################################################
# Classes
###############################################################################

class IterRegistry(type):
    """Helper class for iteration through object properties"""

    def __iter__(self, cls):
        return iter(cls._registry)


class AWS_VPC:
    pass


class AWS_DX_CONNECTION:
    pass


class AWS_DX_INTERFACE:
    pass


###############################################################################
# Module Variables
###############################################################################

_AWS_REGION = os.getenv('AWS_DEFAULT_REGION')
CONST_DIR_TMP = "/tmp"
CONST_WSH_ROOT = os.getenv('WSH_ROOT', '')

###############################################################################
# Functions
###############################################################################


def gv_pprint(v):
    res = []
    if v and type(v) is list:
        for k in v:
            try:
                res.append("{}\n".format(k))
            except TypeError as e:
                pass
    elif v and type(v) is tuple:
        for k in dir(v):
            try:
                res.append("{} {}\n".format(k, getattr(v, k)))
            except TypeError as e:
                pass
    else:
        res.append("{}\n".format(v))
    return '\n// '.join(res)


def gv_safe_id(v):
    if hasattr(v, '__iter__') and hasattr(v, '__next__'):
        return [gv_safe_id(x) for x in v]
    else:
        return v.replace("-", "_") if v else "Unknown"


def gv_safe_name(v):
    try:
        return v.tags['Name']
    except (KeyError, AttributeError) as e:
        return "NoName"


def dict_replace(text, replacements):
    for key, val in replacements.items():
        text = text.replace(key, val)
    return text


def lut_replace(text, replacements):
    return replacements[text] if text in replacements.keys() else text


def unique_items(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]


def _dump_vpcs(vpc_conn=None, ec2_conn=None, dx_conn=None, options=[]):
    """Generates an output from Jinja2 template describing a collection of
    resources within or connected to a VPC"""

    _log.debug('Checking if graphviz is installed for later conversions')
    cmd_dot = sp.find_executable('dot')

    vpc_ids = [options['--vpc-id']] if options.get('--vpc-id') else None

    _log.debug('Retrieving VPC information for {} region'.format(_AWS_REGION))
    ec2_client = boto3.client('ec2', region_name=_AWS_REGION)
    ec2_resource = boto3.resource('ec2', region_name=_AWS_REGION)
    dx_client = boto3.client('directconnect', region_name=_AWS_REGION)

    if vpc_ids:
        vpcs = list(ec2_resource.vpcs.filter(VpcIds=vpc_ids))
    else:
        vpcs = list(ec2_resource.vpcs.all())
    _log.debug('Discovered {0} VPCs'.format(len(vpcs)))

    # Create the jinja2 environment.
    # Notice the use of trim_blocks, which greatly helps control whitespace.
    TEMPLATE_DIR = '{}/etc/visual.d/templates/{}'.format(
        CONST_WSH_ROOT,
        options['--format']
        )

    j2_env = Environment(
        loader=FileSystemLoader(TEMPLATE_DIR),
        trim_blocks=True
        )

    # Add our custom filters
    j2_env.filters['pprint'] = gv_pprint
    j2_env.filters['gv_safe_id'] = gv_safe_id
    j2_env.filters['gv_safe_name'] = gv_safe_name
    j2_env.filters['dict_replace'] = dict_replace
    j2_env.filters['lut_replace'] = lut_replace

    for v in vpcs:

        # Jinja setup
        filename = os.path.abspath('{}/aws-{}.{}'.format(
            options['--output'],
            v.id,
            options['--format']
            ))

        _log.info('Generating output into {}'.format(filename))

        # Subnets
        _log.info('Retrieving Subnet information for {}'.format(v.id))
        subnets = list(ec2_resource.subnets.filter(Filters=[{'Name': 'vpc-id', 'Values': [v.id]}]))
        azs = set(x.availability_zone for x in subnets)
        _log.debug('Discovered {0} objects'.format(len(subnets)))

        instances = security_groups = []
        if not options['--no-ec2']:
            # Instances
            _log.info('Retrieving Instance information for {}'.format(v.id))
            instances = list(ec2_resource.instances.filter(Filters=[{'Name': 'vpc-id', 'Values': [v.id]}]))
            _log.debug('Discovered {0} objects'.format(len(instances)))
            # Security Groups
            _log.info('Retrieving Security Group information for {}'.format(v.id))
            security_groups = list(ec2_resource.security_groups.filter(Filters=[{'Name': 'vpc-id', 'Values': [v.id]}]))
            _log.debug('Discovered {0} objects'.format(len(security_groups)))

        route_tables = main_route_tables = main_route_table = []
        if not options['--no-routing']:
            # Route Tables
            _log.info('Retrieving Route Tables for {}'.format(v.id))
            route_tables = list(ec2_resource.route_tables.filter(Filters=[{'Name': 'vpc-id', 'Values': [v.id]}]))
            _log.debug('Discovered {0} objects'.format(len(route_tables)))

            # Main Route Table
            _log.info('Retrieving Main Route Table for {}'.format(v.id))
            main_route_tables = list(ec2_resource.route_tables.filter(
                Filters=[
                    {'Name': 'vpc-id', 'Values': [v.id]},
                    {'Name': 'association.main', 'Values': ['true']}
                ]
            ))
            _log.debug('Discovered {0} objects'.format(len(main_route_tables)))
            main_route_table = main_route_tables[0] if main_route_tables else None
            if main_route_table:
                _log.info('Main Route Table detected as {0}'.format(main_route_table.id))

        # Internet Gateways
        _log.info('Retrieving Internet Gateway for {}'.format(v.id))
        igw = list(ec2_resource.internet_gateways.filter(Filters=[{'Name': 'attachment.vpc-id', 'Values': [v.id]}]))
        _log.debug('Discovered {0} objects'.format(len(igw)))

        vpngw = vpns = cgws = dx_interfaces = dx_connections = peering_cx = []
        if not options['--no-cx']:
            # Virtual Private Gateways
            _log.info('Retrieving Virtual Private Gateway for {}'.format(v.id))
            vpngw = list(ec2_resource.vpn_gateways.filter(Filters=[{'Name': 'attachment.vpc-id', 'Values': [v.id]}]))
            vpngw_ids = [x.id for x in vpngw]
            _log.debug('Discovered {0} objects'.format(len(vpngw)))

            # VPN Connections
            _log.info('Retrieving VPN Connections for {}'.format(v.id))
            vpns = list(ec2_resource.vpn_connections.filter(Filters=[{'Name': 'vpn-gateway-id', 'Values': vpngw_ids}]))
            vpn_cgw_ids = [x.customer_gateway_id for x in vpns]
            _log.debug('Discovered {0} objects'.format(len(vpns)))

            # Customer Gateways
            _log.info('Retrieving Customer Gateways for {}'.format(v.id))
            cgws = list(ec2_resource.customer_gateways.filter(Filters=[{'Name': 'customer-gateway-id', 'Values': vpn_cgw_ids}]))
            _log.debug('Discovered {0} objects'.format(len(cgws)))

            # DirectConnect - Interfaces
            _log.info('Retrieving DX Interfaces for {}'.format(v.id))
            dx_interfaces = dx_client.describe_virtual_interfaces()['virtualInterfaces']
            dx_interfaces = [x for x in dx_interfaces if x['virtualGatewayId'] in vpngw_ids]
            dx_connection_ids = unique_items([x['connectionId'] for x in dx_interfaces])
            _log.debug('Discovered {0} objects'.format(len(dx_interfaces)))

            # DirectConnect - Connections
            _log.info('Retrieving DX Connections for {}'.format(v.id))
            dx_connections = [dx_client.describe_connections(connectionId=x)['connections'] for x in dx_connection_ids]
            dx_connections = [item for sublist in dx_connections for item in sublist]
            _log.debug('Discovered {0} objects'.format(len(dx_connections)))

            # Peering
            _log.info('Retrieving VPC Peering Connections for {}'.format(v.id))
            peering_cx = list(ec2_resource.vpc_peering_connections.filter(
                Filters=[{'Name': 'requester-vpc-info.vpc-id', 'Values': [v.id]}]
            ))
            _log.debug('Discovered {0} objects'.format(len(peering_cx)))

        # Generate the HTML content
        content = j2_env.get_template('root.j2').render(
            page_title='AWS VPC Summary for VPC {}'.format(v.id),
            WSH_ROOT=CONST_WSH_ROOT,
            graph_direction=options['--dir'],
            region=_AWS_REGION,
            azs=azs,
            vpc=v,
            subnets=subnets,
            instances=instances,
            security_groups=security_groups,
            route_tables=route_tables,
            lut_routetable_origin=LUT_ROUTETABLE_ORIGIN,
            main_route_table=main_route_table,
            igw=igw,
            vpngw=vpngw,
            vpns=vpns,
            cgws=cgws,
            peering_cx=peering_cx,
            dx_interfaces=dx_interfaces,
            dx_connections=dx_connections
        )

        with open(filename, 'w+') as f:
            f.write(content)
            f.close()

        _log.debug('Extra outputs checking: format: {} extra:{} cmd:{}'.format(
            options['--format'],
            options['--extra'],
            cmd_dot)
            )

        if options['--format'] == 'dot' and options['--extra'] and cmd_dot is not None:

            _log.info('Graphviz install detected. Converting DOT to PNG and SVG')

            from subprocess import check_call, CalledProcessError
            try:

                png_filename = os.path.abspath('{}/aws-{}.png'.format(
                    options['--output'],
                    v.id
                    ))
                check_call([cmd_dot, '-Tpng', filename, '-o', png_filename])
                _log.info('Created {}'.format(png_filename))

                svg_filename = os.path.abspath('{}/aws-{}.svg'.format(
                    options['--output'],
                    v.id
                    ))
                check_call([cmd_dot, '-Tsvg', filename, '-o', svg_filename])
                _log.info('Created {}'.format(svg_filename))

            except CalledProcessError as e:
                _log.eror('Error attempting to convert DOT to image formats')


def main(options):
    """
    The main program function
    """

    if options['--debug'] is True:
        import logging
        _log.setLevel(logging.DEBUG)

    for key, value in options.items():
        _log.debug('command-line options: {}: {}'.format(key, value))

    try:
        _dump_vpcs(options=options)
    except AssertionError as e:
        _log.warn(e)
        clean_up(-1)

    clean_up()


if __name__ == "__main__":

    try:
        options = docopt.docopt(__doc__)
        main(options)

    # Handle invalid options
    except docopt.DocoptExit as e:
        print(e.message)
